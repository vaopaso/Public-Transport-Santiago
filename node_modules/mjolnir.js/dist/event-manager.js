'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _hammer = require('./utils/hammer');

var _wheelInput = require('./inputs/wheel-input');

var _wheelInput2 = _interopRequireDefault(_wheelInput);

var _moveInput = require('./inputs/move-input');

var _moveInput2 = _interopRequireDefault(_moveInput);

var _keyInput = require('./inputs/key-input');

var _keyInput2 = _interopRequireDefault(_keyInput);

var _constants = require('./constants');

var _eventUtils = require('./utils/event-utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var DEFAULT_OPTIONS = {
  // event handlers
  events: null,
  // custom recognizers
  recognizers: null,
  // Manager class
  Manager: _hammer.Manager,
  // recognize right button gestures
  rightButton: false,
  // block scrolling - this is a legacy behavior and will be removed in the next version
  legacyBlockScroll: true
};

function preventDefault(evt) {
  evt.preventDefault();
}

// Unified API for subscribing to events about both
// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
// and gestural input (e.g. 'click', 'tap', 'panstart').
// Delegates gesture related event registration and handling to Hammer.js.

var EventManager = function () {
  function EventManager() {
    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, EventManager);

    this.options = (0, _assign2.default)({}, DEFAULT_OPTIONS, options);
    this.eventHandlers = [];

    this._onBasicInput = this._onBasicInput.bind(this);
    this._onOtherEvent = this._onOtherEvent.bind(this);

    this.setElement(element);

    // Register all passed events.
    var events = options.events;

    if (events) {
      this.on(events);
    }
  }

  (0, _createClass3.default)(EventManager, [{
    key: 'setElement',
    value: function setElement(element) {
      var _this = this;

      if (this.element) {
        // unregister all events
        this.destroy();
      }
      this.element = element;
      if (!element) {
        return;
      }

      var options = this.options;

      var ManagerClass = options.Manager;

      this.manager = new ManagerClass(element, { recognizers: options.recognizers || _constants.RECOGNIZERS }).on('hammer.input', this._onBasicInput);

      if (!options.recognizers) {
        // Set default recognize withs
        // http://hammerjs.github.io/recognize-with/
        (0, _keys2.default)(_constants.RECOGNIZER_COMPATIBLE_MAP).forEach(function (name) {
          var recognizer = _this.manager.get(name);
          if (recognizer) {
            _constants.RECOGNIZER_COMPATIBLE_MAP[name].forEach(function (otherName) {
              recognizer.recognizeWith(otherName);
            });
          }
        });
      }

      // Handle events not handled by Hammer.js:
      // - mouse wheel
      // - pointer/touch/mouse move
      this.wheelInput = new _wheelInput2.default(element, this._onOtherEvent, {
        enable: false,
        legacyBlockScroll: options.legacyBlockScroll
      });
      this.moveInput = new _moveInput2.default(element, this._onOtherEvent, { enable: false });
      this.keyInput = new _keyInput2.default(element, this._onOtherEvent, { enable: false });

      if (options.rightButton) {
        // Block right click
        element.addEventListener('contextmenu', preventDefault);
      }

      // Register all existing events
      this.eventHandlers.forEach(function (_ref) {
        var recognizerName = _ref.recognizerName,
            eventAlias = _ref.eventAlias,
            wrappedHandler = _ref.wrappedHandler;

        // Enable recognizer for this event.
        _this._toggleRecognizer(recognizerName, true);
        _this.manager.on(eventAlias, wrappedHandler);
      });
    }

    // Tear down internal event management implementations.

  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.element) {
        this.element.removeEventListener('contextmenu', preventDefault);

        // wheelInput etc. are created in setElement() and therefore
        // cannot exist if there is no element
        this.wheelInput.destroy();
        this.moveInput.destroy();
        this.keyInput.destroy();
        this.manager.destroy();

        this.wheelInput = null;
        this.moveInput = null;
        this.keyInput = null;
        this.manager = null;
        this.element = null;
      }
    }

    // Register an event handler function to be called on `event`.

  }, {
    key: 'on',
    value: function on(event, handler, srcElement) {
      if (typeof event === 'string') {
        this._addEventHandler(event, handler, srcElement);
      } else {
        srcElement = handler;
        // If `event` is a map, call `on()` for each entry.
        for (var eventName in event) {
          this._addEventHandler(eventName, event[eventName], srcElement);
        }
      }
    }

    /**
     * Deregister a previously-registered event handler.
     * @param {string|Object} event   An event name (String) or map of event names to handlers
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: 'off',
    value: function off(event, handler) {
      if (typeof event === 'string') {
        this._removeEventHandler(event, handler);
      } else {
        // If `event` is a map, call `off()` for each entry.
        for (var eventName in event) {
          this._removeEventHandler(eventName, event[eventName]);
        }
      }
    }

    /*
     * Enable/disable recognizer for the given event
     */

  }, {
    key: '_toggleRecognizer',
    value: function _toggleRecognizer(name, enabled) {
      var manager = this.manager;

      if (!manager) {
        return;
      }
      var recognizer = manager.get(name);
      if (recognizer) {
        recognizer.set({ enable: enabled });

        var fallbackRecognizers = _constants.RECOGNIZER_FALLBACK_MAP[name];
        if (fallbackRecognizers && !this.options.recognizers) {
          // Set default require failures
          // http://hammerjs.github.io/require-failure/
          fallbackRecognizers.forEach(function (otherName) {
            var otherRecognizer = manager.get(otherName);
            if (enabled) {
              // Wait for this recognizer to fail
              otherRecognizer.requireFailure(name);
            } else {
              // Do not wait for this recognizer to fail
              otherRecognizer.dropRequireFailure(name);
            }
          });
        }
      }
      this.wheelInput.enableEventType(name, enabled);
      this.moveInput.enableEventType(name, enabled);
      this.keyInput.enableEventType(name, enabled);
    }

    /**
     * Process the event registration for a single event + handler.
     */

  }, {
    key: '_addEventHandler',
    value: function _addEventHandler(event, handler) {
      var srcElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var manager = this.manager,
          eventHandlers = this.eventHandlers;

      var wrappedHandler = this._wrapEventHandler(event, handler, srcElement);
      // Alias to a recognized gesture as necessary.
      var eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
      // Get recognizer for this event
      var recognizerName = _constants.EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
      // Enable recognizer for this event.
      this._toggleRecognizer(recognizerName, true);

      // Find ancestors
      var ancestorEventHandlers = eventHandlers.filter(function (entry) {
        return entry.eventAlias === eventAlias && entry.srcElement !== srcElement && (!entry.srcElement || entry.srcElement.contains(srcElement));
      });

      // Save wrapped handler
      eventHandlers.push({ event: event, eventAlias: eventAlias, recognizerName: recognizerName, srcElement: srcElement,
        handler: handler, wrappedHandler: wrappedHandler });

      // Sort handlers by DOM hierarchy
      // So the event will always fire first on child nodes
      ancestorEventHandlers.forEach(function (entry) {
        return manager.off(eventAlias, entry.wrappedHandler);
      });
      if (manager) {
        manager.on(eventAlias, wrappedHandler);
      }
      ancestorEventHandlers.forEach(function (entry) {
        return manager.on(eventAlias, entry.wrappedHandler);
      });
    }

    /**
     * Process the event deregistration for a single event + handler.
     */

  }, {
    key: '_removeEventHandler',
    value: function _removeEventHandler(event, handler) {
      var manager = this.manager,
          eventHandlers = this.eventHandlers;

      var eventHandlerRemoved = false;

      // Find saved handler if any.
      for (var i = eventHandlers.length; i--;) {
        var entry = eventHandlers[i];
        if (entry.event === event && entry.handler === handler) {
          // Deregister event handler.
          if (manager) {
            manager.off(entry.eventAlias, entry.wrappedHandler);
          }
          // Delete saved handler
          eventHandlers.splice(i, 1);
          eventHandlerRemoved = true;
        }
      }

      if (eventHandlerRemoved) {
        // Alias to a recognized gesture as necessary.
        var eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
        // Get recognizer for this event
        var recognizerName = _constants.EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
        // Disable recognizer if no more handlers are attached to its events
        var isRecognizerUsed = eventHandlers.find(function (entry) {
          return entry.recognizerName === recognizerName;
        });
        if (!isRecognizerUsed) {
          this._toggleRecognizer(recognizerName, false);
        }
      }
    }

    /**
     * Returns an event handler that aliases events and add props before passing
     * to the real handler.
     */

  }, {
    key: '_wrapEventHandler',
    value: function _wrapEventHandler(type, handler, srcElement) {
      var _this2 = this;

      return function (event) {
        var mjolnirEvent = event.mjolnirEvent;


        if (!mjolnirEvent) {
          mjolnirEvent = _this2._normalizeEvent(event);
          event.mjolnirEvent = mjolnirEvent;
        }

        var isStopped = mjolnirEvent.handled && mjolnirEvent.handled !== srcElement;

        if (!isStopped) {
          var isFromDecendant = !srcElement || srcElement.contains(event.srcEvent.target);
          if (isFromDecendant) {
            handler((0, _assign2.default)({}, mjolnirEvent, {
              type: type,
              stopPropagation: function stopPropagation() {
                if (!mjolnirEvent.handled) {
                  mjolnirEvent.handled = srcElement;
                }
              }
            }));
          }
        }
      };
    }

    /**
     * Normalizes hammerjs and custom events to have predictable fields.
     */

  }, {
    key: '_normalizeEvent',
    value: function _normalizeEvent(event) {
      var element = this.element;


      return (0, _assign2.default)({}, event, (0, _eventUtils.whichButtons)(event), (0, _eventUtils.getOffsetPosition)(event, element), {
        handled: false,
        rootElement: element
      });
    }

    /**
     * Handle basic events using the 'hammer.input' Hammer.js API:
     * Before running Recognizers, Hammer emits a 'hammer.input' event
     * with the basic event info. This function emits all basic events
     * aliased to the "class" of event received.
     * See constants.BASIC_EVENT_CLASSES basic event class definitions.
     */

  }, {
    key: '_onBasicInput',
    value: function _onBasicInput(event) {
      var srcEvent = event.srcEvent;

      var alias = _constants.BASIC_EVENT_ALIASES[srcEvent.type];
      if (alias) {
        // fire all events aliased to srcEvent.type
        this.manager.emit(alias, event);
      }
    }

    /**
     * Handle events not supported by Hammer.js,
     * and pipe back out through same (Hammer) channel used by other events.
     */

  }, {
    key: '_onOtherEvent',
    value: function _onOtherEvent(event) {
      this.manager.emit(event.type, event);
    }
  }]);
  return EventManager;
}();

exports.default = EventManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9ldmVudC1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbIkRFRkFVTFRfT1BUSU9OUyIsImV2ZW50cyIsInJlY29nbml6ZXJzIiwiTWFuYWdlciIsInJpZ2h0QnV0dG9uIiwibGVnYWN5QmxvY2tTY3JvbGwiLCJwcmV2ZW50RGVmYXVsdCIsImV2dCIsIkV2ZW50TWFuYWdlciIsImVsZW1lbnQiLCJvcHRpb25zIiwiZXZlbnRIYW5kbGVycyIsIl9vbkJhc2ljSW5wdXQiLCJiaW5kIiwiX29uT3RoZXJFdmVudCIsInNldEVsZW1lbnQiLCJvbiIsImRlc3Ryb3kiLCJNYW5hZ2VyQ2xhc3MiLCJtYW5hZ2VyIiwiZm9yRWFjaCIsInJlY29nbml6ZXIiLCJnZXQiLCJuYW1lIiwicmVjb2duaXplV2l0aCIsIm90aGVyTmFtZSIsIndoZWVsSW5wdXQiLCJlbmFibGUiLCJtb3ZlSW5wdXQiLCJrZXlJbnB1dCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZWNvZ25pemVyTmFtZSIsImV2ZW50QWxpYXMiLCJ3cmFwcGVkSGFuZGxlciIsIl90b2dnbGVSZWNvZ25pemVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiaGFuZGxlciIsInNyY0VsZW1lbnQiLCJfYWRkRXZlbnRIYW5kbGVyIiwiZXZlbnROYW1lIiwiX3JlbW92ZUV2ZW50SGFuZGxlciIsImVuYWJsZWQiLCJzZXQiLCJmYWxsYmFja1JlY29nbml6ZXJzIiwib3RoZXJSZWNvZ25pemVyIiwicmVxdWlyZUZhaWx1cmUiLCJkcm9wUmVxdWlyZUZhaWx1cmUiLCJlbmFibGVFdmVudFR5cGUiLCJfd3JhcEV2ZW50SGFuZGxlciIsImFuY2VzdG9yRXZlbnRIYW5kbGVycyIsImZpbHRlciIsImVudHJ5IiwiY29udGFpbnMiLCJwdXNoIiwib2ZmIiwiZXZlbnRIYW5kbGVyUmVtb3ZlZCIsImkiLCJsZW5ndGgiLCJzcGxpY2UiLCJpc1JlY29nbml6ZXJVc2VkIiwiZmluZCIsInR5cGUiLCJtam9sbmlyRXZlbnQiLCJfbm9ybWFsaXplRXZlbnQiLCJpc1N0b3BwZWQiLCJoYW5kbGVkIiwiaXNGcm9tRGVjZW5kYW50Iiwic3JjRXZlbnQiLCJ0YXJnZXQiLCJzdG9wUHJvcGFnYXRpb24iLCJyb290RWxlbWVudCIsImFsaWFzIiwiZW1pdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7QUFTQTs7OztBQW5DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFtQkEsSUFBTUEsa0JBQWtCO0FBQ3RCO0FBQ0FDLFVBQVEsSUFGYztBQUd0QjtBQUNBQyxlQUFhLElBSlM7QUFLdEI7QUFDQUMsMEJBTnNCO0FBT3RCO0FBQ0FDLGVBQWEsS0FSUztBQVN0QjtBQUNBQyxxQkFBbUI7QUFWRyxDQUF4Qjs7QUFhQSxTQUFTQyxjQUFULENBQXdCQyxHQUF4QixFQUE2QjtBQUMzQkEsTUFBSUQsY0FBSjtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztJQUNxQkUsWTtBQUNuQiwwQkFBMEM7QUFBQSxRQUE5QkMsT0FBOEIsdUVBQXBCLElBQW9CO0FBQUEsUUFBZEMsT0FBYyx1RUFBSixFQUFJO0FBQUE7O0FBQ3hDLFNBQUtBLE9BQUwsR0FBZSxzQkFBYyxFQUFkLEVBQWtCVixlQUFsQixFQUFtQ1UsT0FBbkMsQ0FBZjtBQUNBLFNBQUtDLGFBQUwsR0FBcUIsRUFBckI7O0FBRUEsU0FBS0MsYUFBTCxHQUFxQixLQUFLQSxhQUFMLENBQW1CQyxJQUFuQixDQUF3QixJQUF4QixDQUFyQjtBQUNBLFNBQUtDLGFBQUwsR0FBcUIsS0FBS0EsYUFBTCxDQUFtQkQsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FBckI7O0FBRUEsU0FBS0UsVUFBTCxDQUFnQk4sT0FBaEI7O0FBRUE7QUFUd0MsUUFVakNSLE1BVmlDLEdBVXZCUyxPQVZ1QixDQVVqQ1Qs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RUFBTztBQUFBLFVBQ2QzQixPQURjLEdBQ0gsSUFERyxDQUNkQSxPQURjOzs7QUFHckIsYUFBTyxzQkFBYyxFQUFkLEVBQWtCMkIsS0FBbEIsRUFDTCw4QkFBYUEsS0FBYixDQURLLEVBRUwsbUNBQWtCQSxLQUFsQixFQUF5QjNCLE9BQXpCLENBRkssRUFHTDtBQUNFeUQsaUJBQVMsS0FEWDtBQUVFSyxxQkFBYTlEO0FBRmYsT0FISyxDQUFQO0FBT0Q7O0FBRUQ7Ozs7Ozs7Ozs7a0NBT2MyQixLLEVBQU87QUFBQSxVQUNaZ0MsUUFEWSxHQUNBaEMsS0FEQSxDQUNaZ0MsUUFEWTs7QUFFbkIsVUFBTUksUUFBUSwrQkFBb0JKLFNBQVNOLElBQTdCLENBQWQ7QUFDQSxVQUFJVSxLQUFKLEVBQVc7QUFDVDtBQUNBLGFBQUtyRCxPQUFMLENBQWFzRCxJQUFiLENBQWtCRCxLQUFsQixFQUF5QnBDLEtBQXpCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7OztrQ0FJY0EsSyxFQUFPO0FBQ25CLFdBQUtqQixPQUFMLENBQWFzRCxJQUFiLENBQWtCckMsTUFBTTBCLElBQXhCLEVBQThCMUIsS0FBOUI7QUFDRDs7Ozs7a0JBaFNrQjVCLFkiLCJmaWxlIjoiZXZlbnQtbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TWFuYWdlcn0gZnJvbSAnLi91dGlscy9oYW1tZXInO1xuXG5pbXBvcnQgV2hlZWxJbnB1dCBmcm9tICcuL2lucHV0cy93aGVlbC1pbnB1dCc7XG5pbXBvcnQgTW92ZUlucHV0IGZyb20gJy4vaW5wdXRzL21vdmUtaW5wdXQnO1xuaW1wb3J0IEtleUlucHV0IGZyb20gJy4vaW5wdXRzL2tleS1pbnB1dCc7XG5cbmltcG9ydCB7XG4gIEJBU0lDX0VWRU5UX0FMSUFTRVMsXG4gIEVWRU5UX1JFQ09HTklaRVJfTUFQLFxuICBHRVNUVVJFX0VWRU5UX0FMSUFTRVMsXG4gIFJFQ09HTklaRVJTLFxuICBSRUNPR05JWkVSX0NPTVBBVElCTEVfTUFQLFxuICBSRUNPR05JWkVSX0ZBTExCQUNLX01BUFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmltcG9ydCB7d2hpY2hCdXR0b25zLCBnZXRPZmZzZXRQb3NpdGlvbn0gZnJvbSAnLi91dGlscy9ldmVudC11dGlscyc7XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgZXZlbnRzOiBudWxsLFxuICAvLyBjdXN0b20gcmVjb2duaXplcnNcbiAgcmVjb2duaXplcnM6IG51bGwsXG4gIC8vIE1hbmFnZXIgY2xhc3NcbiAgTWFuYWdlcixcbiAgLy8gcmVjb2duaXplIHJpZ2h0IGJ1dHRvbiBnZXN0dXJlc1xuICByaWdodEJ1dHRvbjogZmFsc2UsXG4gIC8vIGJsb2NrIHNjcm9sbGluZyAtIHRoaXMgaXMgYSBsZWdhY3kgYmVoYXZpb3IgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCB2ZXJzaW9uXG4gIGxlZ2FjeUJsb2NrU2Nyb2xsOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldnQpIHtcbiAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbi8vIFVuaWZpZWQgQVBJIGZvciBzdWJzY3JpYmluZyB0byBldmVudHMgYWJvdXQgYm90aFxuLy8gYmFzaWMgaW5wdXQgZXZlbnRzIChlLmcuICdtb3VzZW1vdmUnLCAndG91Y2hzdGFydCcsICd3aGVlbCcpXG4vLyBhbmQgZ2VzdHVyYWwgaW5wdXQgKGUuZy4gJ2NsaWNrJywgJ3RhcCcsICdwYW5zdGFydCcpLlxuLy8gRGVsZWdhdGVzIGdlc3R1cmUgcmVsYXRlZCBldmVudCByZWdpc3RyYXRpb24gYW5kIGhhbmRsaW5nIHRvIEhhbW1lci5qcy5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQgPSBudWxsLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IFtdO1xuXG4gICAgdGhpcy5fb25CYXNpY0lucHV0ID0gdGhpcy5fb25CYXNpY0lucHV0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25PdGhlckV2ZW50ID0gdGhpcy5fb25PdGhlckV2ZW50LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnNldEVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAvLyBSZWdpc3RlciBhbGwgcGFzc2VkIGV2ZW50cy5cbiAgICBjb25zdCB7ZXZlbnRzfSA9IG9wdGlvbnM7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgdGhpcy5vbihldmVudHMpO1xuICAgIH1cbiAgfVxuXG4gIHNldEVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgIC8vIHVucmVnaXN0ZXIgYWxsIGV2ZW50c1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge29wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBNYW5hZ2VyQ2xhc3MgPSBvcHRpb25zLk1hbmFnZXI7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSBuZXcgTWFuYWdlckNsYXNzKGVsZW1lbnQsIHtyZWNvZ25pemVyczogb3B0aW9ucy5yZWNvZ25pemVycyB8fCBSRUNPR05JWkVSU30pXG4gICAgICAub24oJ2hhbW1lci5pbnB1dCcsIHRoaXMuX29uQmFzaWNJbnB1dCk7XG5cbiAgICBpZiAoIW9wdGlvbnMucmVjb2duaXplcnMpIHtcbiAgICAgIC8vIFNldCBkZWZhdWx0IHJlY29nbml6ZSB3aXRoc1xuICAgICAgLy8gaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZWNvZ25pemUtd2l0aC9cbiAgICAgIE9iamVjdC5rZXlzKFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVApLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlY29nbml6ZXIgPSB0aGlzLm1hbmFnZXIuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICAgIFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVBbbmFtZV0uZm9yRWFjaChvdGhlck5hbWUgPT4ge1xuICAgICAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKG90aGVyTmFtZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBldmVudHMgbm90IGhhbmRsZWQgYnkgSGFtbWVyLmpzOlxuICAgIC8vIC0gbW91c2Ugd2hlZWxcbiAgICAvLyAtIHBvaW50ZXIvdG91Y2gvbW91c2UgbW92ZVxuICAgIHRoaXMud2hlZWxJbnB1dCA9IG5ldyBXaGVlbElucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge1xuICAgICAgZW5hYmxlOiBmYWxzZSxcbiAgICAgIGxlZ2FjeUJsb2NrU2Nyb2xsOiBvcHRpb25zLmxlZ2FjeUJsb2NrU2Nyb2xsXG4gICAgfSk7XG4gICAgdGhpcy5tb3ZlSW5wdXQgPSBuZXcgTW92ZUlucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge2VuYWJsZTogZmFsc2V9KTtcbiAgICB0aGlzLmtleUlucHV0ID0gbmV3IEtleUlucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge2VuYWJsZTogZmFsc2V9KTtcblxuICAgIGlmIChvcHRpb25zLnJpZ2h0QnV0dG9uKSB7XG4gICAgICAvLyBCbG9jayByaWdodCBjbGlja1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBhbGwgZXhpc3RpbmcgZXZlbnRzXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2goKHtyZWNvZ25pemVyTmFtZSwgZXZlbnRBbGlhcywgd3JhcHBlZEhhbmRsZXJ9KSA9PiB7XG4gICAgICAvLyBFbmFibGUgcmVjb2duaXplciBmb3IgdGhpcyBldmVudC5cbiAgICAgIHRoaXMuX3RvZ2dsZVJlY29nbml6ZXIocmVjb2duaXplck5hbWUsIHRydWUpO1xuICAgICAgdGhpcy5tYW5hZ2VyLm9uKGV2ZW50QWxpYXMsIHdyYXBwZWRIYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRlYXIgZG93biBpbnRlcm5hbCBldmVudCBtYW5hZ2VtZW50IGltcGxlbWVudGF0aW9ucy5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG5cbiAgICAgIC8vIHdoZWVsSW5wdXQgZXRjLiBhcmUgY3JlYXRlZCBpbiBzZXRFbGVtZW50KCkgYW5kIHRoZXJlZm9yZVxuICAgICAgLy8gY2Fubm90IGV4aXN0IGlmIHRoZXJlIGlzIG5vIGVsZW1lbnRcbiAgICAgIHRoaXMud2hlZWxJbnB1dC5kZXN0cm95KCk7XG4gICAgICB0aGlzLm1vdmVJbnB1dC5kZXN0cm95KCk7XG4gICAgICB0aGlzLmtleUlucHV0LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubWFuYWdlci5kZXN0cm95KCk7XG5cbiAgICAgIHRoaXMud2hlZWxJbnB1dCA9IG51bGw7XG4gICAgICB0aGlzLm1vdmVJbnB1dCA9IG51bGw7XG4gICAgICB0aGlzLmtleUlucHV0ID0gbnVsbDtcbiAgICAgIHRoaXMubWFuYWdlciA9IG51bGw7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlZ2lzdGVyIGFuIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGBldmVudGAuXG4gIG9uKGV2ZW50LCBoYW5kbGVyLCBzcmNFbGVtZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlciwgc3JjRWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNyY0VsZW1lbnQgPSBoYW5kbGVyO1xuICAgICAgLy8gSWYgYGV2ZW50YCBpcyBhIG1hcCwgY2FsbCBgb24oKWAgZm9yIGVhY2ggZW50cnkuXG4gICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBpbiBldmVudCkge1xuICAgICAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoZXZlbnROYW1lLCBldmVudFtldmVudE5hbWVdLCBzcmNFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHByZXZpb3VzbHktcmVnaXN0ZXJlZCBldmVudCBoYW5kbGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGV2ZW50ICAgQW4gZXZlbnQgbmFtZSAoU3RyaW5nKSBvciBtYXAgb2YgZXZlbnQgbmFtZXMgdG8gaGFuZGxlcnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdICAgIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYGV2ZW50YC5cbiAgICovXG4gIG9mZihldmVudCwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBgZXZlbnRgIGlzIGEgbWFwLCBjYWxsIGBvZmYoKWAgZm9yIGVhY2ggZW50cnkuXG4gICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBpbiBldmVudCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnROYW1lLCBldmVudFtldmVudE5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiBFbmFibGUvZGlzYWJsZSByZWNvZ25pemVyIGZvciB0aGUgZ2l2ZW4gZXZlbnRcbiAgICovXG4gIF90b2dnbGVSZWNvZ25pemVyKG5hbWUsIGVuYWJsZWQpIHtcbiAgICBjb25zdCB7bWFuYWdlcn0gPSB0aGlzO1xuICAgIGlmICghbWFuYWdlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWNvZ25pemVyID0gbWFuYWdlci5nZXQobmFtZSk7XG4gICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgIHJlY29nbml6ZXIuc2V0KHtlbmFibGU6IGVuYWJsZWR9KTtcblxuICAgICAgY29uc3QgZmFsbGJhY2tSZWNvZ25pemVycyA9IFJFQ09HTklaRVJfRkFMTEJBQ0tfTUFQW25hbWVdO1xuICAgICAgaWYgKGZhbGxiYWNrUmVjb2duaXplcnMgJiYgIXRoaXMub3B0aW9ucy5yZWNvZ25pemVycykge1xuICAgICAgICAvLyBTZXQgZGVmYXVsdCByZXF1aXJlIGZhaWx1cmVzXG4gICAgICAgIC8vIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vcmVxdWlyZS1mYWlsdXJlL1xuICAgICAgICBmYWxsYmFja1JlY29nbml6ZXJzLmZvckVhY2gob3RoZXJOYW1lID0+IHtcbiAgICAgICAgICBjb25zdCBvdGhlclJlY29nbml6ZXIgPSBtYW5hZ2VyLmdldChvdGhlck5hbWUpO1xuICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBXYWl0IGZvciB0aGlzIHJlY29nbml6ZXIgdG8gZmFpbFxuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKG5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEbyBub3Qgd2FpdCBmb3IgdGhpcyByZWNvZ25pemVyIHRvIGZhaWxcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5kcm9wUmVxdWlyZUZhaWx1cmUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy53aGVlbElucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgICB0aGlzLm1vdmVJbnB1dC5lbmFibGVFdmVudFR5cGUobmFtZSwgZW5hYmxlZCk7XG4gICAgdGhpcy5rZXlJbnB1dC5lbmFibGVFdmVudFR5cGUobmFtZSwgZW5hYmxlZCk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgZXZlbnQgcmVnaXN0cmF0aW9uIGZvciBhIHNpbmdsZSBldmVudCArIGhhbmRsZXIuXG4gICAqL1xuICBfYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBzcmNFbGVtZW50ID0gbnVsbCkge1xuICAgIGNvbnN0IHttYW5hZ2VyLCBldmVudEhhbmRsZXJzfSA9IHRoaXM7XG4gICAgY29uc3Qgd3JhcHBlZEhhbmRsZXIgPSB0aGlzLl93cmFwRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBzcmNFbGVtZW50KTtcbiAgICAvLyBBbGlhcyB0byBhIHJlY29nbml6ZWQgZ2VzdHVyZSBhcyBuZWNlc3NhcnkuXG4gICAgY29uc3QgZXZlbnRBbGlhcyA9IEdFU1RVUkVfRVZFTlRfQUxJQVNFU1tldmVudF0gfHwgZXZlbnQ7XG4gICAgLy8gR2V0IHJlY29nbml6ZXIgZm9yIHRoaXMgZXZlbnRcbiAgICBjb25zdCByZWNvZ25pemVyTmFtZSA9IEVWRU5UX1JFQ09HTklaRVJfTUFQW2V2ZW50QWxpYXNdIHx8IGV2ZW50QWxpYXM7XG4gICAgLy8gRW5hYmxlIHJlY29nbml6ZXIgZm9yIHRoaXMgZXZlbnQuXG4gICAgdGhpcy5fdG9nZ2xlUmVjb2duaXplcihyZWNvZ25pemVyTmFtZSwgdHJ1ZSk7XG5cbiAgICAvLyBGaW5kIGFuY2VzdG9yc1xuICAgIGNvbnN0IGFuY2VzdG9yRXZlbnRIYW5kbGVycyA9IGV2ZW50SGFuZGxlcnMuZmlsdGVyKGVudHJ5ID0+IHtcbiAgICAgIHJldHVybiBlbnRyeS5ldmVudEFsaWFzID09PSBldmVudEFsaWFzICYmXG4gICAgICAgIGVudHJ5LnNyY0VsZW1lbnQgIT09IHNyY0VsZW1lbnQgJiZcbiAgICAgICAgKCFlbnRyeS5zcmNFbGVtZW50IHx8IGVudHJ5LnNyY0VsZW1lbnQuY29udGFpbnMoc3JjRWxlbWVudCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2F2ZSB3cmFwcGVkIGhhbmRsZXJcbiAgICBldmVudEhhbmRsZXJzLnB1c2goe2V2ZW50LCBldmVudEFsaWFzLCByZWNvZ25pemVyTmFtZSwgc3JjRWxlbWVudCxcbiAgICAgIGhhbmRsZXIsIHdyYXBwZWRIYW5kbGVyfSk7XG5cbiAgICAvLyBTb3J0IGhhbmRsZXJzIGJ5IERPTSBoaWVyYXJjaHlcbiAgICAvLyBTbyB0aGUgZXZlbnQgd2lsbCBhbHdheXMgZmlyZSBmaXJzdCBvbiBjaGlsZCBub2Rlc1xuICAgIGFuY2VzdG9yRXZlbnRIYW5kbGVycy5mb3JFYWNoKGVudHJ5ID0+IG1hbmFnZXIub2ZmKGV2ZW50QWxpYXMsIGVudHJ5LndyYXBwZWRIYW5kbGVyKSk7XG4gICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgIG1hbmFnZXIub24oZXZlbnRBbGlhcywgd3JhcHBlZEhhbmRsZXIpO1xuICAgIH1cbiAgICBhbmNlc3RvckV2ZW50SGFuZGxlcnMuZm9yRWFjaChlbnRyeSA9PiBtYW5hZ2VyLm9uKGV2ZW50QWxpYXMsIGVudHJ5LndyYXBwZWRIYW5kbGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgZXZlbnQgZGVyZWdpc3RyYXRpb24gZm9yIGEgc2luZ2xlIGV2ZW50ICsgaGFuZGxlci5cbiAgICovXG4gIF9yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBjb25zdCB7bWFuYWdlciwgZXZlbnRIYW5kbGVyc30gPSB0aGlzO1xuICAgIGxldCBldmVudEhhbmRsZXJSZW1vdmVkID0gZmFsc2U7XG5cbiAgICAvLyBGaW5kIHNhdmVkIGhhbmRsZXIgaWYgYW55LlxuICAgIGZvciAobGV0IGkgPSBldmVudEhhbmRsZXJzLmxlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgZW50cnkgPSBldmVudEhhbmRsZXJzW2ldO1xuICAgICAgaWYgKGVudHJ5LmV2ZW50ID09PSBldmVudCAmJiBlbnRyeS5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICAgIC8vIERlcmVnaXN0ZXIgZXZlbnQgaGFuZGxlci5cbiAgICAgICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgICBtYW5hZ2VyLm9mZihlbnRyeS5ldmVudEFsaWFzLCBlbnRyeS53cmFwcGVkSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVsZXRlIHNhdmVkIGhhbmRsZXJcbiAgICAgICAgZXZlbnRIYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGV2ZW50SGFuZGxlclJlbW92ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChldmVudEhhbmRsZXJSZW1vdmVkKSB7XG4gICAgICAvLyBBbGlhcyB0byBhIHJlY29nbml6ZWQgZ2VzdHVyZSBhcyBuZWNlc3NhcnkuXG4gICAgICBjb25zdCBldmVudEFsaWFzID0gR0VTVFVSRV9FVkVOVF9BTElBU0VTW2V2ZW50XSB8fCBldmVudDtcbiAgICAgIC8vIEdldCByZWNvZ25pemVyIGZvciB0aGlzIGV2ZW50XG4gICAgICBjb25zdCByZWNvZ25pemVyTmFtZSA9IEVWRU5UX1JFQ09HTklaRVJfTUFQW2V2ZW50QWxpYXNdIHx8IGV2ZW50QWxpYXM7XG4gICAgICAvLyBEaXNhYmxlIHJlY29nbml6ZXIgaWYgbm8gbW9yZSBoYW5kbGVycyBhcmUgYXR0YWNoZWQgdG8gaXRzIGV2ZW50c1xuICAgICAgY29uc3QgaXNSZWNvZ25pemVyVXNlZCA9IGV2ZW50SGFuZGxlcnMuZmluZChcbiAgICAgICAgZW50cnkgPT4gZW50cnkucmVjb2duaXplck5hbWUgPT09IHJlY29nbml6ZXJOYW1lXG4gICAgICApO1xuICAgICAgaWYgKCFpc1JlY29nbml6ZXJVc2VkKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVJlY29nbml6ZXIocmVjb2duaXplck5hbWUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBldmVudCBoYW5kbGVyIHRoYXQgYWxpYXNlcyBldmVudHMgYW5kIGFkZCBwcm9wcyBiZWZvcmUgcGFzc2luZ1xuICAgKiB0byB0aGUgcmVhbCBoYW5kbGVyLlxuICAgKi9cbiAgX3dyYXBFdmVudEhhbmRsZXIodHlwZSwgaGFuZGxlciwgc3JjRWxlbWVudCkge1xuICAgIHJldHVybiBldmVudCA9PiB7XG4gICAgICBsZXQge21qb2xuaXJFdmVudH0gPSBldmVudDtcblxuICAgICAgaWYgKCFtam9sbmlyRXZlbnQpIHtcbiAgICAgICAgbWpvbG5pckV2ZW50ID0gdGhpcy5fbm9ybWFsaXplRXZlbnQoZXZlbnQpO1xuICAgICAgICBldmVudC5tam9sbmlyRXZlbnQgPSBtam9sbmlyRXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzU3RvcHBlZCA9IG1qb2xuaXJFdmVudC5oYW5kbGVkICYmIG1qb2xuaXJFdmVudC5oYW5kbGVkICE9PSBzcmNFbGVtZW50O1xuXG4gICAgICBpZiAoIWlzU3RvcHBlZCkge1xuICAgICAgICBjb25zdCBpc0Zyb21EZWNlbmRhbnQgPSAhc3JjRWxlbWVudCB8fCBzcmNFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnNyY0V2ZW50LnRhcmdldCk7XG4gICAgICAgIGlmIChpc0Zyb21EZWNlbmRhbnQpIHtcbiAgICAgICAgICBoYW5kbGVyKE9iamVjdC5hc3NpZ24oe30sIG1qb2xuaXJFdmVudCwge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIW1qb2xuaXJFdmVudC5oYW5kbGVkKSB7XG4gICAgICAgICAgICAgICAgbWpvbG5pckV2ZW50LmhhbmRsZWQgPSBzcmNFbGVtZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIGhhbW1lcmpzIGFuZCBjdXN0b20gZXZlbnRzIHRvIGhhdmUgcHJlZGljdGFibGUgZmllbGRzLlxuICAgKi9cbiAgX25vcm1hbGl6ZUV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3Qge2VsZW1lbnR9ID0gdGhpcztcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBldmVudCxcbiAgICAgIHdoaWNoQnV0dG9ucyhldmVudCksXG4gICAgICBnZXRPZmZzZXRQb3NpdGlvbihldmVudCwgZWxlbWVudCksXG4gICAgICB7XG4gICAgICAgIGhhbmRsZWQ6IGZhbHNlLFxuICAgICAgICByb290RWxlbWVudDogZWxlbWVudFxuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGJhc2ljIGV2ZW50cyB1c2luZyB0aGUgJ2hhbW1lci5pbnB1dCcgSGFtbWVyLmpzIEFQSTpcbiAgICogQmVmb3JlIHJ1bm5pbmcgUmVjb2duaXplcnMsIEhhbW1lciBlbWl0cyBhICdoYW1tZXIuaW5wdXQnIGV2ZW50XG4gICAqIHdpdGggdGhlIGJhc2ljIGV2ZW50IGluZm8uIFRoaXMgZnVuY3Rpb24gZW1pdHMgYWxsIGJhc2ljIGV2ZW50c1xuICAgKiBhbGlhc2VkIHRvIHRoZSBcImNsYXNzXCIgb2YgZXZlbnQgcmVjZWl2ZWQuXG4gICAqIFNlZSBjb25zdGFudHMuQkFTSUNfRVZFTlRfQ0xBU1NFUyBiYXNpYyBldmVudCBjbGFzcyBkZWZpbml0aW9ucy5cbiAgICovXG4gIF9vbkJhc2ljSW5wdXQoZXZlbnQpIHtcbiAgICBjb25zdCB7c3JjRXZlbnR9ID0gZXZlbnQ7XG4gICAgY29uc3QgYWxpYXMgPSBCQVNJQ19FVkVOVF9BTElBU0VTW3NyY0V2ZW50LnR5cGVdO1xuICAgIGlmIChhbGlhcykge1xuICAgICAgLy8gZmlyZSBhbGwgZXZlbnRzIGFsaWFzZWQgdG8gc3JjRXZlbnQudHlwZVxuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQoYWxpYXMsIGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGV2ZW50cyBub3Qgc3VwcG9ydGVkIGJ5IEhhbW1lci5qcyxcbiAgICogYW5kIHBpcGUgYmFjayBvdXQgdGhyb3VnaCBzYW1lIChIYW1tZXIpIGNoYW5uZWwgdXNlZCBieSBvdGhlciBldmVudHMuXG4gICAqL1xuICBfb25PdGhlckV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5tYW5hZ2VyLmVtaXQoZXZlbnQudHlwZSwgZXZlbnQpO1xuICB9XG59XG4iXX0=