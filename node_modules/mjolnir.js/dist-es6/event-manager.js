var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import { Manager } from './utils/hammer';

import WheelInput from './inputs/wheel-input';
import MoveInput from './inputs/move-input';
import KeyInput from './inputs/key-input';

import { BASIC_EVENT_ALIASES, EVENT_RECOGNIZER_MAP, GESTURE_EVENT_ALIASES, RECOGNIZERS, RECOGNIZER_COMPATIBLE_MAP, RECOGNIZER_FALLBACK_MAP } from './constants';

import { whichButtons, getOffsetPosition } from './utils/event-utils';

var DEFAULT_OPTIONS = {
  // event handlers
  events: null,
  // custom recognizers
  recognizers: null,
  // Manager class
  Manager: Manager,
  // recognize right button gestures
  rightButton: false,
  // block scrolling - this is a legacy behavior and will be removed in the next version
  legacyBlockScroll: true
};

function preventDefault(evt) {
  evt.preventDefault();
}

// Unified API for subscribing to events about both
// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
// and gestural input (e.g. 'click', 'tap', 'panstart').
// Delegates gesture related event registration and handling to Hammer.js.

var EventManager = function () {
  function EventManager() {
    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, EventManager);

    this.options = Object.assign({}, DEFAULT_OPTIONS, options);
    this.eventHandlers = [];

    this._onBasicInput = this._onBasicInput.bind(this);
    this._onOtherEvent = this._onOtherEvent.bind(this);

    this.setElement(element);

    // Register all passed events.
    var events = options.events;

    if (events) {
      this.on(events);
    }
  }

  _createClass(EventManager, [{
    key: 'setElement',
    value: function setElement(element) {
      var _this = this;

      if (this.element) {
        // unregister all events
        this.destroy();
      }
      this.element = element;
      if (!element) {
        return;
      }

      var options = this.options;

      var ManagerClass = options.Manager;

      this.manager = new ManagerClass(element, { recognizers: options.recognizers || RECOGNIZERS }).on('hammer.input', this._onBasicInput);

      if (!options.recognizers) {
        // Set default recognize withs
        // http://hammerjs.github.io/recognize-with/
        Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(function (name) {
          var recognizer = _this.manager.get(name);
          if (recognizer) {
            RECOGNIZER_COMPATIBLE_MAP[name].forEach(function (otherName) {
              recognizer.recognizeWith(otherName);
            });
          }
        });
      }

      // Handle events not handled by Hammer.js:
      // - mouse wheel
      // - pointer/touch/mouse move
      this.wheelInput = new WheelInput(element, this._onOtherEvent, {
        enable: false,
        legacyBlockScroll: options.legacyBlockScroll
      });
      this.moveInput = new MoveInput(element, this._onOtherEvent, { enable: false });
      this.keyInput = new KeyInput(element, this._onOtherEvent, { enable: false });

      if (options.rightButton) {
        // Block right click
        element.addEventListener('contextmenu', preventDefault);
      }

      // Register all existing events
      this.eventHandlers.forEach(function (_ref) {
        var recognizerName = _ref.recognizerName,
            eventAlias = _ref.eventAlias,
            wrappedHandler = _ref.wrappedHandler;

        // Enable recognizer for this event.
        _this._toggleRecognizer(recognizerName, true);
        _this.manager.on(eventAlias, wrappedHandler);
      });
    }

    // Tear down internal event management implementations.

  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.element) {
        this.element.removeEventListener('contextmenu', preventDefault);

        // wheelInput etc. are created in setElement() and therefore
        // cannot exist if there is no element
        this.wheelInput.destroy();
        this.moveInput.destroy();
        this.keyInput.destroy();
        this.manager.destroy();

        this.wheelInput = null;
        this.moveInput = null;
        this.keyInput = null;
        this.manager = null;
        this.element = null;
      }
    }

    // Register an event handler function to be called on `event`.

  }, {
    key: 'on',
    value: function on(event, handler, srcElement) {
      if (typeof event === 'string') {
        this._addEventHandler(event, handler, srcElement);
      } else {
        srcElement = handler;
        // If `event` is a map, call `on()` for each entry.
        for (var eventName in event) {
          this._addEventHandler(eventName, event[eventName], srcElement);
        }
      }
    }

    /**
     * Deregister a previously-registered event handler.
     * @param {string|Object} event   An event name (String) or map of event names to handlers
     * @param {Function} [handler]    The function to be called on `event`.
     */

  }, {
    key: 'off',
    value: function off(event, handler) {
      if (typeof event === 'string') {
        this._removeEventHandler(event, handler);
      } else {
        // If `event` is a map, call `off()` for each entry.
        for (var eventName in event) {
          this._removeEventHandler(eventName, event[eventName]);
        }
      }
    }

    /*
     * Enable/disable recognizer for the given event
     */

  }, {
    key: '_toggleRecognizer',
    value: function _toggleRecognizer(name, enabled) {
      var manager = this.manager;

      if (!manager) {
        return;
      }
      var recognizer = manager.get(name);
      if (recognizer) {
        recognizer.set({ enable: enabled });

        var fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];
        if (fallbackRecognizers && !this.options.recognizers) {
          // Set default require failures
          // http://hammerjs.github.io/require-failure/
          fallbackRecognizers.forEach(function (otherName) {
            var otherRecognizer = manager.get(otherName);
            if (enabled) {
              // Wait for this recognizer to fail
              otherRecognizer.requireFailure(name);
            } else {
              // Do not wait for this recognizer to fail
              otherRecognizer.dropRequireFailure(name);
            }
          });
        }
      }
      this.wheelInput.enableEventType(name, enabled);
      this.moveInput.enableEventType(name, enabled);
      this.keyInput.enableEventType(name, enabled);
    }

    /**
     * Process the event registration for a single event + handler.
     */

  }, {
    key: '_addEventHandler',
    value: function _addEventHandler(event, handler) {
      var srcElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var manager = this.manager,
          eventHandlers = this.eventHandlers;

      var wrappedHandler = this._wrapEventHandler(event, handler, srcElement);
      // Alias to a recognized gesture as necessary.
      var eventAlias = GESTURE_EVENT_ALIASES[event] || event;
      // Get recognizer for this event
      var recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
      // Enable recognizer for this event.
      this._toggleRecognizer(recognizerName, true);

      // Find ancestors
      var ancestorEventHandlers = eventHandlers.filter(function (entry) {
        return entry.eventAlias === eventAlias && entry.srcElement !== srcElement && (!entry.srcElement || entry.srcElement.contains(srcElement));
      });

      // Save wrapped handler
      eventHandlers.push({ event: event, eventAlias: eventAlias, recognizerName: recognizerName, srcElement: srcElement,
        handler: handler, wrappedHandler: wrappedHandler });

      // Sort handlers by DOM hierarchy
      // So the event will always fire first on child nodes
      ancestorEventHandlers.forEach(function (entry) {
        return manager.off(eventAlias, entry.wrappedHandler);
      });
      if (manager) {
        manager.on(eventAlias, wrappedHandler);
      }
      ancestorEventHandlers.forEach(function (entry) {
        return manager.on(eventAlias, entry.wrappedHandler);
      });
    }

    /**
     * Process the event deregistration for a single event + handler.
     */

  }, {
    key: '_removeEventHandler',
    value: function _removeEventHandler(event, handler) {
      var manager = this.manager,
          eventHandlers = this.eventHandlers;

      var eventHandlerRemoved = false;

      // Find saved handler if any.
      for (var i = eventHandlers.length; i--;) {
        var entry = eventHandlers[i];
        if (entry.event === event && entry.handler === handler) {
          // Deregister event handler.
          if (manager) {
            manager.off(entry.eventAlias, entry.wrappedHandler);
          }
          // Delete saved handler
          eventHandlers.splice(i, 1);
          eventHandlerRemoved = true;
        }
      }

      if (eventHandlerRemoved) {
        // Alias to a recognized gesture as necessary.
        var eventAlias = GESTURE_EVENT_ALIASES[event] || event;
        // Get recognizer for this event
        var recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
        // Disable recognizer if no more handlers are attached to its events
        var isRecognizerUsed = eventHandlers.find(function (entry) {
          return entry.recognizerName === recognizerName;
        });
        if (!isRecognizerUsed) {
          this._toggleRecognizer(recognizerName, false);
        }
      }
    }

    /**
     * Returns an event handler that aliases events and add props before passing
     * to the real handler.
     */

  }, {
    key: '_wrapEventHandler',
    value: function _wrapEventHandler(type, handler, srcElement) {
      var _this2 = this;

      return function (event) {
        var mjolnirEvent = event.mjolnirEvent;


        if (!mjolnirEvent) {
          mjolnirEvent = _this2._normalizeEvent(event);
          event.mjolnirEvent = mjolnirEvent;
        }

        var isStopped = mjolnirEvent.handled && mjolnirEvent.handled !== srcElement;

        if (!isStopped) {
          var isFromDecendant = !srcElement || srcElement.contains(event.srcEvent.target);
          if (isFromDecendant) {
            handler(Object.assign({}, mjolnirEvent, {
              type: type,
              stopPropagation: function stopPropagation() {
                if (!mjolnirEvent.handled) {
                  mjolnirEvent.handled = srcElement;
                }
              }
            }));
          }
        }
      };
    }

    /**
     * Normalizes hammerjs and custom events to have predictable fields.
     */

  }, {
    key: '_normalizeEvent',
    value: function _normalizeEvent(event) {
      var element = this.element;


      return Object.assign({}, event, whichButtons(event), getOffsetPosition(event, element), {
        handled: false,
        rootElement: element
      });
    }

    /**
     * Handle basic events using the 'hammer.input' Hammer.js API:
     * Before running Recognizers, Hammer emits a 'hammer.input' event
     * with the basic event info. This function emits all basic events
     * aliased to the "class" of event received.
     * See constants.BASIC_EVENT_CLASSES basic event class definitions.
     */

  }, {
    key: '_onBasicInput',
    value: function _onBasicInput(event) {
      var srcEvent = event.srcEvent;

      var alias = BASIC_EVENT_ALIASES[srcEvent.type];
      if (alias) {
        // fire all events aliased to srcEvent.type
        this.manager.emit(alias, event);
      }
    }

    /**
     * Handle events not supported by Hammer.js,
     * and pipe back out through same (Hammer) channel used by other events.
     */

  }, {
    key: '_onOtherEvent',
    value: function _onOtherEvent(event) {
      this.manager.emit(event.type, event);
    }
  }]);

  return EventManager;
}();

export default EventManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9ldmVudC1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbIk1hbmFnZXIiLCJXaGVlbElucHV0IiwiTW92ZUlucHV0IiwiS2V5SW5wdXQiLCJCQVNJQ19FVkVOVF9BTElBU0VTIiwiRVZFTlRfUkVDT0dOSVpFUl9NQVAiLCJHRVNUVVJFX0VWRU5UX0FMSUFTRVMiLCJSRUNPR05JWkVSUyIsIlJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVAiLCJSRUNPR05JWkVSX0ZBTExCQUNLX01BUCIsIndoaWNoQnV0dG9ucyIsImdldE9mZnNldFBvc2l0aW9uIiwiREVGQVVMVF9PUFRJT05TIiwiZXZlbnRzIiwicmVjb2duaXplcnMiLCJyaWdodEJ1dHRvbiIsImxlZ2FjeUJsb2NrU2Nyb2xsIiwicHJldmVudERlZmF1bHQiLCJldnQiLCJFdmVudE1hbmFnZXIiLCJlbGVtZW50Iiwib3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsImV2ZW50SGFuZGxlcnMiLCJfb25CYXNpY0lucHV0IiwiYmluZCIsIl9vbk90aGVyRXZlbnQiLCJzZXRFbGVtZW50Iiwib24iLCJkZXN0cm95IiwiTWFuYWdlckNsYXNzIiwibWFuYWdlciIsImtleXMiLCJmb3JFYWNoIiwicmVjb2duaXplciIsImdldCIsIm5hbWUiLCJyZWNvZ25pemVXaXRoIiwib3RoZXJOYW1lIiwid2hlZWxJbnB1dCIsImVuYWJsZSIsIm1vdmVJbnB1dCIsImtleUlucHV0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlY29nbml6ZXJOYW1lIiwiZXZlbnRBbGlhcyIsIndyYXBwZWRIYW5kbGVyIiwiX3RvZ2dsZVJlY29nbml6ZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJoYW5kbGVyIiwic3JjRWxlbWVudCIsIl9hZGRFdmVudEhhbmRsZXIiLCJldmVudE5hbWUiLCJfcmVtb3ZlRXZlbnRIYW5kbGVyIiwiZW5hYmxlZCIsInNldCIsImZhbGxiYWNrUmVjb2duaXplcnMiLCJvdGhlclJlY29nbml6ZXIiLCJyZXF1aXJlRmFpbHVyZSIsImRyb3BSZXF1aXJlRmFpbHVyZSIsImVuYWJsZUV2ZW50VHlwZSIsIl93cmFwRXZlbnRIYW5kbGVyIiwiYW5jZXN0b3JFdmVudEhhbmRsZXJzIiwiZmlsdGVyIiwiZW50cnkiLCJjb250YWlucyIsInB1c2giLCJvZmYiLCJldmVudEhhbmRsZXJSZW1vdmVkIiwiaSIsImxlbmd0aCIsInNwbGljZSIsImlzUmVjb2duaXplclVzZWQiLCJmaW5kIiwidHlwZSIsIm1qb2xuaXJFdmVudCIsIl9ub3JtYWxpemVFdmVudCIsImlzU3RvcHBlZCIsImhhbmRsZWQiLCJpc0Zyb21EZWNlbmRhbnQiLCJzcmNFdmVudCIsInRhcmdldCIsInN0b3BQcm9wYWdhdGlvbiIsInJvb3RFbGVtZW50IiwiYWxpYXMiLCJlbWl0Il0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUUEsT0FBUixRQUFzQixnQkFBdEI7O0FBRUEsT0FBT0MsVUFBUCxNQUF1QixzQkFBdkI7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLHFCQUF0QjtBQUNBLE9BQU9DLFFBQVAsTUFBcUIsb0JBQXJCOztBQUVBLFNBQ0VDLG1CQURGLEVBRUVDLG9CQUZGLEVBR0VDLHFCQUhGLEVBSUVDLFdBSkYsRUFLRUMseUJBTEYsRUFNRUMsdUJBTkYsUUFPTyxhQVBQOztBQVNBLFNBQVFDLFlBQVIsRUFBc0JDLGlCQUF0QixRQUE4QyxxQkFBOUM7O0FBRUEsSUFBTUMsa0JBQWtCO0FBQ3RCO0FBQ0FDLFVBQVEsSUFGYztBQUd0QjtBQUNBQyxlQUFhLElBSlM7QUFLdEI7QUFDQWQsa0JBTnNCO0FBT3RCO0FBQ0FlLGVBQWEsS0FSUztBQVN0QjtBQUNBQyxxQkFBbUI7QUFWRyxDQUF4Qjs7QUFhQSxTQUFTQyxjQUFULENBQXdCQyxHQUF4QixFQUE2QjtBQUMzQkEsTUFB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Q0FBYXVELElBQWIsQ0FBa0JELEtBQWxCLEVBQXlCcEMsS0FBekI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7O2tDQUljQSxLLEVBQU87QUFDbkIsV0FBS2xCLE9BQUwsQ0FBYXVELElBQWIsQ0FBa0JyQyxNQUFNMEIsSUFBeEIsRUFBOEIxQixLQUE5QjtBQUNEOzs7Ozs7ZUFoU2tCL0IsWSIsImZpbGUiOiJldmVudC1tYW5hZ2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtNYW5hZ2VyfSBmcm9tICcuL3V0aWxzL2hhbW1lcic7XG5cbmltcG9ydCBXaGVlbElucHV0IGZyb20gJy4vaW5wdXRzL3doZWVsLWlucHV0JztcbmltcG9ydCBNb3ZlSW5wdXQgZnJvbSAnLi9pbnB1dHMvbW92ZS1pbnB1dCc7XG5pbXBvcnQgS2V5SW5wdXQgZnJvbSAnLi9pbnB1dHMva2V5LWlucHV0JztcblxuaW1wb3J0IHtcbiAgQkFTSUNfRVZFTlRfQUxJQVNFUyxcbiAgRVZFTlRfUkVDT0dOSVpFUl9NQVAsXG4gIEdFU1RVUkVfRVZFTlRfQUxJQVNFUyxcbiAgUkVDT0dOSVpFUlMsXG4gIFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVAsXG4gIFJFQ09HTklaRVJfRkFMTEJBQ0tfTUFQXG59IGZyb20gJy4vY29uc3RhbnRzJztcblxuaW1wb3J0IHt3aGljaEJ1dHRvbnMsIGdldE9mZnNldFBvc2l0aW9ufSBmcm9tICcuL3V0aWxzL2V2ZW50LXV0aWxzJztcblxuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICAvLyBldmVudCBoYW5kbGVyc1xuICBldmVudHM6IG51bGwsXG4gIC8vIGN1c3RvbSByZWNvZ25pemVyc1xuICByZWNvZ25pemVyczogbnVsbCxcbiAgLy8gTWFuYWdlciBjbGFzc1xuICBNYW5hZ2VyLFxuICAvLyByZWNvZ25pemUgcmlnaHQgYnV0dG9uIGdlc3R1cmVzXG4gIHJpZ2h0QnV0dG9uOiBmYWxzZSxcbiAgLy8gYmxvY2sgc2Nyb2xsaW5nIC0gdGhpcyBpcyBhIGxlZ2FjeSBiZWhhdmlvciBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IHZlcnNpb25cbiAgbGVnYWN5QmxvY2tTY3JvbGw6IHRydWVcbn07XG5cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2dCkge1xuICBldnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuLy8gVW5pZmllZCBBUEkgZm9yIHN1YnNjcmliaW5nIHRvIGV2ZW50cyBhYm91dCBib3RoXG4vLyBiYXNpYyBpbnB1dCBldmVudHMgKGUuZy4gJ21vdXNlbW92ZScsICd0b3VjaHN0YXJ0JywgJ3doZWVsJylcbi8vIGFuZCBnZXN0dXJhbCBpbnB1dCAoZS5nLiAnY2xpY2snLCAndGFwJywgJ3BhbnN0YXJ0JykuXG4vLyBEZWxlZ2F0ZXMgZ2VzdHVyZSByZWxhdGVkIGV2ZW50IHJlZ2lzdHJhdGlvbiBhbmQgaGFuZGxpbmcgdG8gSGFtbWVyLmpzLlxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCA9IG51bGwsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XG4gICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW107XG5cbiAgICB0aGlzLl9vbkJhc2ljSW5wdXQgPSB0aGlzLl9vbkJhc2ljSW5wdXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk90aGVyRXZlbnQgPSB0aGlzLl9vbk90aGVyRXZlbnQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuc2V0RWxlbWVudChlbGVtZW50KTtcblxuICAgIC8vIFJlZ2lzdGVyIGFsbCBwYXNzZWQgZXZlbnRzLlxuICAgIGNvbnN0IHtldmVudHN9ID0gb3B0aW9ucztcbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICB0aGlzLm9uKGV2ZW50cyk7XG4gICAgfVxuICB9XG5cbiAgc2V0RWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgLy8gdW5yZWdpc3RlciBhbGwgZXZlbnRzXG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7b3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IE1hbmFnZXJDbGFzcyA9IG9wdGlvbnMuTWFuYWdlcjtcblxuICAgIHRoaXMubWFuYWdlciA9IG5ldyBNYW5hZ2VyQ2xhc3MoZWxlbWVudCwge3JlY29nbml6ZXJzOiBvcHRpb25zLnJlY29nbml6ZXJzIHx8IFJFQ09HTklaRVJTfSlcbiAgICAgIC5vbignaGFtbWVyLmlucHV0JywgdGhpcy5fb25CYXNpY0lucHV0KTtcblxuICAgIGlmICghb3B0aW9ucy5yZWNvZ25pemVycykge1xuICAgICAgLy8gU2V0IGRlZmF1bHQgcmVjb2duaXplIHdpdGhzXG4gICAgICAvLyBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL3JlY29nbml6ZS13aXRoL1xuICAgICAgT2JqZWN0LmtleXMoUkVDT0dOSVpFUl9DT01QQVRJQkxFX01BUCkuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgY29uc3QgcmVjb2duaXplciA9IHRoaXMubWFuYWdlci5nZXQobmFtZSk7XG4gICAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgICAgUkVDT0dOSVpFUl9DT01QQVRJQkxFX01BUFtuYW1lXS5mb3JFYWNoKG90aGVyTmFtZSA9PiB7XG4gICAgICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgob3RoZXJOYW1lKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGV2ZW50cyBub3QgaGFuZGxlZCBieSBIYW1tZXIuanM6XG4gICAgLy8gLSBtb3VzZSB3aGVlbFxuICAgIC8vIC0gcG9pbnRlci90b3VjaC9tb3VzZSBtb3ZlXG4gICAgdGhpcy53aGVlbElucHV0ID0gbmV3IFdoZWVsSW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7XG4gICAgICBlbmFibGU6IGZhbHNlLFxuICAgICAgbGVnYWN5QmxvY2tTY3JvbGw6IG9wdGlvbnMubGVnYWN5QmxvY2tTY3JvbGxcbiAgICB9KTtcbiAgICB0aGlzLm1vdmVJbnB1dCA9IG5ldyBNb3ZlSW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7ZW5hYmxlOiBmYWxzZX0pO1xuICAgIHRoaXMua2V5SW5wdXQgPSBuZXcgS2V5SW5wdXQoZWxlbWVudCwgdGhpcy5fb25PdGhlckV2ZW50LCB7ZW5hYmxlOiBmYWxzZX0pO1xuXG4gICAgaWYgKG9wdGlvbnMucmlnaHRCdXR0b24pIHtcbiAgICAgIC8vIEJsb2NrIHJpZ2h0IGNsaWNrXG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcHJldmVudERlZmF1bHQpO1xuICAgIH1cblxuICAgIC8vIFJlZ2lzdGVyIGFsbCBleGlzdGluZyBldmVudHNcbiAgICB0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaCgoe3JlY29nbml6ZXJOYW1lLCBldmVudEFsaWFzLCB3cmFwcGVkSGFuZGxlcn0pID0+IHtcbiAgICAgIC8vIEVuYWJsZSByZWNvZ25pemVyIGZvciB0aGlzIGV2ZW50LlxuICAgICAgdGhpcy5fdG9nZ2xlUmVjb2duaXplcihyZWNvZ25pemVyTmFtZSwgdHJ1ZSk7XG4gICAgICB0aGlzLm1hbmFnZXIub24oZXZlbnRBbGlhcywgd3JhcHBlZEhhbmRsZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVGVhciBkb3duIGludGVybmFsIGV2ZW50IG1hbmFnZW1lbnQgaW1wbGVtZW50YXRpb25zLlxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcblxuICAgICAgLy8gd2hlZWxJbnB1dCBldGMuIGFyZSBjcmVhdGVkIGluIHNldEVsZW1lbnQoKSBhbmQgdGhlcmVmb3JlXG4gICAgICAvLyBjYW5ub3QgZXhpc3QgaWYgdGhlcmUgaXMgbm8gZWxlbWVudFxuICAgICAgdGhpcy53aGVlbElucHV0LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubW92ZUlucHV0LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMua2V5SW5wdXQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5tYW5hZ2VyLmRlc3Ryb3koKTtcblxuICAgICAgdGhpcy53aGVlbElucHV0ID0gbnVsbDtcbiAgICAgIHRoaXMubW92ZUlucHV0ID0gbnVsbDtcbiAgICAgIHRoaXMua2V5SW5wdXQgPSBudWxsO1xuICAgICAgdGhpcy5tYW5hZ2VyID0gbnVsbDtcbiAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVnaXN0ZXIgYW4gZXZlbnQgaGFuZGxlciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYGV2ZW50YC5cbiAgb24oZXZlbnQsIGhhbmRsZXIsIHNyY0VsZW1lbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBzcmNFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3JjRWxlbWVudCA9IGhhbmRsZXI7XG4gICAgICAvLyBJZiBgZXZlbnRgIGlzIGEgbWFwLCBjYWxsIGBvbigpYCBmb3IgZWFjaCBlbnRyeS5cbiAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50SGFuZGxlcihldmVudE5hbWUsIGV2ZW50W2V2ZW50TmFtZV0sIHNyY0VsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgcHJldmlvdXNseS1yZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gZXZlbnQgICBBbiBldmVudCBuYW1lIChTdHJpbmcpIG9yIG1hcCBvZiBldmVudCBuYW1lcyB0byBoYW5kbGVyc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0gICAgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBgZXZlbnRgLlxuICAgKi9cbiAgb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGBldmVudGAgaXMgYSBtYXAsIGNhbGwgYG9mZigpYCBmb3IgZWFjaCBlbnRyeS5cbiAgICAgIGZvciAoY29uc3QgZXZlbnROYW1lIGluIGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudE5hbWUsIGV2ZW50W2V2ZW50TmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIEVuYWJsZS9kaXNhYmxlIHJlY29nbml6ZXIgZm9yIHRoZSBnaXZlbiBldmVudFxuICAgKi9cbiAgX3RvZ2dsZVJlY29nbml6ZXIobmFtZSwgZW5hYmxlZCkge1xuICAgIGNvbnN0IHttYW5hZ2VyfSA9IHRoaXM7XG4gICAgaWYgKCFtYW5hZ2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlY29nbml6ZXIgPSBtYW5hZ2VyLmdldChuYW1lKTtcbiAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgcmVjb2duaXplci5zZXQoe2VuYWJsZTogZW5hYmxlZH0pO1xuXG4gICAgICBjb25zdCBmYWxsYmFja1JlY29nbml6ZXJzID0gUkVDT0dOSVpFUl9GQUxMQkFDS19NQVBbbmFtZV07XG4gICAgICBpZiAoZmFsbGJhY2tSZWNvZ25pemVycyAmJiAhdGhpcy5vcHRpb25zLnJlY29nbml6ZXJzKSB7XG4gICAgICAgIC8vIFNldCBkZWZhdWx0IHJlcXVpcmUgZmFpbHVyZXNcbiAgICAgICAgLy8gaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZXF1aXJlLWZhaWx1cmUvXG4gICAgICAgIGZhbGxiYWNrUmVjb2duaXplcnMuZm9yRWFjaChvdGhlck5hbWUgPT4ge1xuICAgICAgICAgIGNvbnN0IG90aGVyUmVjb2duaXplciA9IG1hbmFnZXIuZ2V0KG90aGVyTmFtZSk7XG4gICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoaXMgcmVjb2duaXplciB0byBmYWlsXG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUobmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCB3YWl0IGZvciB0aGlzIHJlY29nbml6ZXIgdG8gZmFpbFxuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLmRyb3BSZXF1aXJlRmFpbHVyZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndoZWVsSW5wdXQuZW5hYmxlRXZlbnRUeXBlKG5hbWUsIGVuYWJsZWQpO1xuICAgIHRoaXMubW92ZUlucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgICB0aGlzLmtleUlucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBldmVudCByZWdpc3RyYXRpb24gZm9yIGEgc2luZ2xlIGV2ZW50ICsgaGFuZGxlci5cbiAgICovXG4gIF9hZGRFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIsIHNyY0VsZW1lbnQgPSBudWxsKSB7XG4gICAgY29uc3Qge21hbmFnZXIsIGV2ZW50SGFuZGxlcnN9ID0gdGhpcztcbiAgICBjb25zdCB3cmFwcGVkSGFuZGxlciA9IHRoaXMuX3dyYXBFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIsIHNyY0VsZW1lbnQpO1xuICAgIC8vIEFsaWFzIHRvIGEgcmVjb2duaXplZCBnZXN0dXJlIGFzIG5lY2Vzc2FyeS5cbiAgICBjb25zdCBldmVudEFsaWFzID0gR0VTVFVSRV9FVkVOVF9BTElBU0VTW2V2ZW50XSB8fCBldmVudDtcbiAgICAvLyBHZXQgcmVjb2duaXplciBmb3IgdGhpcyBldmVudFxuICAgIGNvbnN0IHJlY29nbml6ZXJOYW1lID0gRVZFTlRfUkVDT0dOSVpFUl9NQVBbZXZlbnRBbGlhc10gfHwgZXZlbnRBbGlhcztcbiAgICAvLyBFbmFibGUgcmVjb2duaXplciBmb3IgdGhpcyBldmVudC5cbiAgICB0aGlzLl90b2dnbGVSZWNvZ25pemVyKHJlY29nbml6ZXJOYW1lLCB0cnVlKTtcblxuICAgIC8vIEZpbmQgYW5jZXN0b3JzXG4gICAgY29uc3QgYW5jZXN0b3JFdmVudEhhbmRsZXJzID0gZXZlbnRIYW5kbGVycy5maWx0ZXIoZW50cnkgPT4ge1xuICAgICAgcmV0dXJuIGVudHJ5LmV2ZW50QWxpYXMgPT09IGV2ZW50QWxpYXMgJiZcbiAgICAgICAgZW50cnkuc3JjRWxlbWVudCAhPT0gc3JjRWxlbWVudCAmJlxuICAgICAgICAoIWVudHJ5LnNyY0VsZW1lbnQgfHwgZW50cnkuc3JjRWxlbWVudC5jb250YWlucyhzcmNFbGVtZW50KSk7XG4gICAgfSk7XG5cbiAgICAvLyBTYXZlIHdyYXBwZWQgaGFuZGxlclxuICAgIGV2ZW50SGFuZGxlcnMucHVzaCh7ZXZlbnQsIGV2ZW50QWxpYXMsIHJlY29nbml6ZXJOYW1lLCBzcmNFbGVtZW50LFxuICAgICAgaGFuZGxlciwgd3JhcHBlZEhhbmRsZXJ9KTtcblxuICAgIC8vIFNvcnQgaGFuZGxlcnMgYnkgRE9NIGhpZXJhcmNoeVxuICAgIC8vIFNvIHRoZSBldmVudCB3aWxsIGFsd2F5cyBmaXJlIGZpcnN0IG9uIGNoaWxkIG5vZGVzXG4gICAgYW5jZXN0b3JFdmVudEhhbmRsZXJzLmZvckVhY2goZW50cnkgPT4gbWFuYWdlci5vZmYoZXZlbnRBbGlhcywgZW50cnkud3JhcHBlZEhhbmRsZXIpKTtcbiAgICBpZiAobWFuYWdlcikge1xuICAgICAgbWFuYWdlci5vbihldmVudEFsaWFzLCB3cmFwcGVkSGFuZGxlcik7XG4gICAgfVxuICAgIGFuY2VzdG9yRXZlbnRIYW5kbGVycy5mb3JFYWNoKGVudHJ5ID0+IG1hbmFnZXIub24oZXZlbnRBbGlhcywgZW50cnkud3JhcHBlZEhhbmRsZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBldmVudCBkZXJlZ2lzdHJhdGlvbiBmb3IgYSBzaW5nbGUgZXZlbnQgKyBoYW5kbGVyLlxuICAgKi9cbiAgX3JlbW92ZUV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlcikge1xuICAgIGNvbnN0IHttYW5hZ2VyLCBldmVudEhhbmRsZXJzfSA9IHRoaXM7XG4gICAgbGV0IGV2ZW50SGFuZGxlclJlbW92ZWQgPSBmYWxzZTtcblxuICAgIC8vIEZpbmQgc2F2ZWQgaGFuZGxlciBpZiBhbnkuXG4gICAgZm9yIChsZXQgaSA9IGV2ZW50SGFuZGxlcnMubGVuZ3RoOyBpLS07KSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGV2ZW50SGFuZGxlcnNbaV07XG4gICAgICBpZiAoZW50cnkuZXZlbnQgPT09IGV2ZW50ICYmIGVudHJ5LmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgICAgLy8gRGVyZWdpc3RlciBldmVudCBoYW5kbGVyLlxuICAgICAgICBpZiAobWFuYWdlcikge1xuICAgICAgICAgIG1hbmFnZXIub2ZmKGVudHJ5LmV2ZW50QWxpYXMsIGVudHJ5LndyYXBwZWRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxldGUgc2F2ZWQgaGFuZGxlclxuICAgICAgICBldmVudEhhbmRsZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgZXZlbnRIYW5kbGVyUmVtb3ZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50SGFuZGxlclJlbW92ZWQpIHtcbiAgICAgIC8vIEFsaWFzIHRvIGEgcmVjb2duaXplZCBnZXN0dXJlIGFzIG5lY2Vzc2FyeS5cbiAgICAgIGNvbnN0IGV2ZW50QWxpYXMgPSBHRVNUVVJFX0VWRU5UX0FMSUFTRVNbZXZlbnRdIHx8IGV2ZW50O1xuICAgICAgLy8gR2V0IHJlY29nbml6ZXIgZm9yIHRoaXMgZXZlbnRcbiAgICAgIGNvbnN0IHJlY29nbml6ZXJOYW1lID0gRVZFTlRfUkVDT0dOSVpFUl9NQVBbZXZlbnRBbGlhc10gfHwgZXZlbnRBbGlhcztcbiAgICAgIC8vIERpc2FibGUgcmVjb2duaXplciBpZiBubyBtb3JlIGhhbmRsZXJzIGFyZSBhdHRhY2hlZCB0byBpdHMgZXZlbnRzXG4gICAgICBjb25zdCBpc1JlY29nbml6ZXJVc2VkID0gZXZlbnRIYW5kbGVycy5maW5kKFxuICAgICAgICBlbnRyeSA9PiBlbnRyeS5yZWNvZ25pemVyTmFtZSA9PT0gcmVjb2duaXplck5hbWVcbiAgICAgICk7XG4gICAgICBpZiAoIWlzUmVjb2duaXplclVzZWQpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlUmVjb2duaXplcihyZWNvZ25pemVyTmFtZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV2ZW50IGhhbmRsZXIgdGhhdCBhbGlhc2VzIGV2ZW50cyBhbmQgYWRkIHByb3BzIGJlZm9yZSBwYXNzaW5nXG4gICAqIHRvIHRoZSByZWFsIGhhbmRsZXIuXG4gICAqL1xuICBfd3JhcEV2ZW50SGFuZGxlcih0eXBlLCBoYW5kbGVyLCBzcmNFbGVtZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50ID0+IHtcbiAgICAgIGxldCB7bWpvbG5pckV2ZW50fSA9IGV2ZW50O1xuXG4gICAgICBpZiAoIW1qb2xuaXJFdmVudCkge1xuICAgICAgICBtam9sbmlyRXZlbnQgPSB0aGlzLl9ub3JtYWxpemVFdmVudChldmVudCk7XG4gICAgICAgIGV2ZW50Lm1qb2xuaXJFdmVudCA9IG1qb2xuaXJFdmVudDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNTdG9wcGVkID0gbWpvbG5pckV2ZW50LmhhbmRsZWQgJiYgbWpvbG5pckV2ZW50LmhhbmRsZWQgIT09IHNyY0VsZW1lbnQ7XG5cbiAgICAgIGlmICghaXNTdG9wcGVkKSB7XG4gICAgICAgIGNvbnN0IGlzRnJvbURlY2VuZGFudCA9ICFzcmNFbGVtZW50IHx8IHNyY0VsZW1lbnQuY29udGFpbnMoZXZlbnQuc3JjRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgaWYgKGlzRnJvbURlY2VuZGFudCkge1xuICAgICAgICAgIGhhbmRsZXIoT2JqZWN0LmFzc2lnbih7fSwgbWpvbG5pckV2ZW50LCB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICghbWpvbG5pckV2ZW50LmhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgICBtam9sbmlyRXZlbnQuaGFuZGxlZCA9IHNyY0VsZW1lbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgaGFtbWVyanMgYW5kIGN1c3RvbSBldmVudHMgdG8gaGF2ZSBwcmVkaWN0YWJsZSBmaWVsZHMuXG4gICAqL1xuICBfbm9ybWFsaXplRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB7ZWxlbWVudH0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGV2ZW50LFxuICAgICAgd2hpY2hCdXR0b25zKGV2ZW50KSxcbiAgICAgIGdldE9mZnNldFBvc2l0aW9uKGV2ZW50LCBlbGVtZW50KSxcbiAgICAgIHtcbiAgICAgICAgaGFuZGxlZDogZmFsc2UsXG4gICAgICAgIHJvb3RFbGVtZW50OiBlbGVtZW50XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYmFzaWMgZXZlbnRzIHVzaW5nIHRoZSAnaGFtbWVyLmlucHV0JyBIYW1tZXIuanMgQVBJOlxuICAgKiBCZWZvcmUgcnVubmluZyBSZWNvZ25pemVycywgSGFtbWVyIGVtaXRzIGEgJ2hhbW1lci5pbnB1dCcgZXZlbnRcbiAgICogd2l0aCB0aGUgYmFzaWMgZXZlbnQgaW5mby4gVGhpcyBmdW5jdGlvbiBlbWl0cyBhbGwgYmFzaWMgZXZlbnRzXG4gICAqIGFsaWFzZWQgdG8gdGhlIFwiY2xhc3NcIiBvZiBldmVudCByZWNlaXZlZC5cbiAgICogU2VlIGNvbnN0YW50cy5CQVNJQ19FVkVOVF9DTEFTU0VTIGJhc2ljIGV2ZW50IGNsYXNzIGRlZmluaXRpb25zLlxuICAgKi9cbiAgX29uQmFzaWNJbnB1dChldmVudCkge1xuICAgIGNvbnN0IHtzcmNFdmVudH0gPSBldmVudDtcbiAgICBjb25zdCBhbGlhcyA9IEJBU0lDX0VWRU5UX0FMSUFTRVNbc3JjRXZlbnQudHlwZV07XG4gICAgaWYgKGFsaWFzKSB7XG4gICAgICAvLyBmaXJlIGFsbCBldmVudHMgYWxpYXNlZCB0byBzcmNFdmVudC50eXBlXG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdChhbGlhcywgZXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgZXZlbnRzIG5vdCBzdXBwb3J0ZWQgYnkgSGFtbWVyLmpzLFxuICAgKiBhbmQgcGlwZSBiYWNrIG91dCB0aHJvdWdoIHNhbWUgKEhhbW1lcikgY2hhbm5lbCB1c2VkIGJ5IG90aGVyIGV2ZW50cy5cbiAgICovXG4gIF9vbk90aGVyRXZlbnQoZXZlbnQpIHtcbiAgICB0aGlzLm1hbmFnZXIuZW1pdChldmVudC50eXBlLCBldmVudCk7XG4gIH1cbn1cbiJdfQ==